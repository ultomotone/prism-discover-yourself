<!DOCTYPE html>
<html lang="en">
  <head>
    <!-- Disable Attribution Reporting API to avoid third-party attestation errors (e.g., Facebook Pixel) -->
    <meta http-equiv="Permissions-Policy" content="attribution-reporting=()" />
    <script>
      (function configureSupabase() {
        const existing = (function readExistingConfig() {
          try {
            const candidate = window.__APP_CONFIG__;
            return candidate && typeof candidate === 'object' ? candidate : {};
          } catch (_) {
            return {};
          }
        })();

        function normaliseEnv(raw) {
          if (typeof raw !== 'string') return undefined;
          const trimmed = raw.trim();
          if (!trimmed || trimmed === 'undefined' || trimmed === 'null') {
            return undefined;
          }
          return trimmed;
        }

        const envSupabaseUrl = normaliseEnv("https://gnkuikentdtnatazeriu.supabase.co");
        const envSupabaseAnonKey = normaliseEnv("eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Imdua3Vpa2VudGR0bmF0YXplcml1Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTM3MzI2MDQsImV4cCI6MjA2OTMwODYwNH0.wCk8ngoDqGW4bMIAjH5EttXsoBwdk4xnIViJZCezs-U");
        const envSupabaseFunctionUrl = normaliseEnv(
          "https://gnkuikentdtnatazeriu.functions.supabase.co"
        );
        const envQuoraPixelId = normaliseEnv("<%= import.meta.env.VITE_QUORA_PIXEL_ID %>");
        const envEnableQuoraPixel = normaliseEnv("<%= import.meta.env.VITE_ENABLE_QUORA_PIXEL %>");

        const defaultConfig = {
          REDDIT_PIXEL_ID: "a2_hisg7r10d2ta", // Default Reddit Pixel ID
          LINKEDIN_SITE_PAGE_VIEW_ID: null,
          LINKEDIN_LEAD_CONVERSION_ID: null,
          LINKEDIN_SIGNUP_CONVERSION_ID: null,
          LINKEDIN_PURCHASE_CONVERSION_ID: null,
          LINKEDIN_ADD_TO_CART_CONVERSION_ID: null,
        };

        const config = Object.assign({}, defaultConfig, existing);

        if (envSupabaseUrl) {
          config.SUPABASE_URL = envSupabaseUrl;
        }

        if (envSupabaseAnonKey) {
          config.SUPABASE_ANON_KEY = envSupabaseAnonKey;
        }

        if (envSupabaseFunctionUrl) {
          config.SUPABASE_FUNCTION_URL = envSupabaseFunctionUrl;
        }

        if (
          (!config.QUORA_PIXEL_ID || typeof config.QUORA_PIXEL_ID !== 'string' || !config.QUORA_PIXEL_ID.trim()) &&
          envQuoraPixelId
        ) {
          config.QUORA_PIXEL_ID = envQuoraPixelId;
        }

        if (typeof envEnableQuoraPixel === 'string') {
          const lowered = envEnableQuoraPixel.toLowerCase();
          if (lowered === 'true' || lowered === '1') {
            config.ENABLE_QUORA_PIXEL = true;
          } else if (lowered === 'false' || lowered === '0') {
            config.ENABLE_QUORA_PIXEL = false;
          }
        }

        const normaliseUrl = (value) =>
          typeof value === 'string' ? value.replace(/\/+$/, '') : undefined;

        const supabaseUrl = normaliseUrl(config.SUPABASE_URL);
        const configuredFunctionsUrl = normaliseUrl(config.SUPABASE_FUNCTION_URL);
        const functionsUrl = configuredFunctionsUrl
          || (supabaseUrl && supabaseUrl.includes('.supabase.co')
            ? supabaseUrl.replace('.supabase.co', '.functions.supabase.co')
            : undefined);

        if (functionsUrl) {
          config.SUPABASE_FUNCTION_URL = functionsUrl;
        }

        window.__APP_CONFIG__ = config;

        const anonKey = config.SUPABASE_ANON_KEY;

        const supabaseOrigin = (function deriveSupabaseOrigin() {
          try {
            return supabaseUrl ? new URL(supabaseUrl).origin : null;
          } catch (_) {
            return null;
          }
        })();

        const functionsOrigin = (function deriveFunctionsOrigin() {
          try {
            return functionsUrl ? new URL(functionsUrl).origin : null;
          } catch (_) {
            return null;
          }
        })();

        function normaliseFunctionPath(path) {
          const trimmed = path.replace(/^\/+/, '');
          return trimmed.startsWith('functions/v1/')
            ? trimmed.slice('functions/v1/'.length)
            : trimmed;
        }

        function buildTargetFromRelative(path) {
          try {
            const parsed = new URL(path.replace(/^\/+/, ''), 'https://placeholder.local/');
            const normalised = normaliseFunctionPath(parsed.pathname);
            let target = `${functionsUrl}/${normalised}`;
            if (parsed.search) target += parsed.search;
            if (parsed.hash) target += parsed.hash;
            return target;
          } catch (_) {
            return `${functionsUrl}/${normaliseFunctionPath(path)}`;
          }
        }

        window.__supabaseFunctionFetch = function(path, init) {
          if (!functionsUrl) {
            return Promise.reject(new Error('Supabase functions URL is not configured'));
          }

          function resolveInput(raw) {
            if (typeof raw === 'string') return raw;
            if (raw && typeof raw === 'object') {
              if (typeof raw.url === 'string') return raw.url;
            }
            return '';
          }

          const candidate = resolveInput(path);

          let target;
          if (candidate && /^https?:/i.test(candidate)) {
            try {
              const parsed = new URL(candidate);
              const normalisedPath = normaliseFunctionPath(parsed.pathname);
              const shouldRewrite =
                normalisedPath &&
                parsed.pathname.startsWith('/functions/') &&
                ((supabaseOrigin && parsed.origin === supabaseOrigin) ||
                  (functionsOrigin && parsed.origin === functionsOrigin));

              if (shouldRewrite) {
                target = `${functionsUrl}/${normalisedPath}${parsed.search}${parsed.hash}`;
              } else {
                target = candidate;
              }
            } catch (_) {
              target = buildTargetFromRelative(candidate);
            }
          } else {
            target = buildTargetFromRelative(candidate);
          }

          const requestInit = Object.assign({}, init);
          const headerBag = new Headers(requestInit.headers || {});

          if (anonKey) {
            if (!headerBag.has('apikey')) headerBag.set('apikey', anonKey);
            if (!headerBag.has('Authorization')) headerBag.set('Authorization', `Bearer ${anonKey}`);
          }

          requestInit.headers = headerBag;
          return fetch(target, requestInit);
        };

        window.__invokeSupabaseEdge = function(path, init) {
          const normalised = normaliseFunctionPath(String(path || ''));
          try {
            const invoker = window.__supabaseFunctionFetch;
            if (typeof invoker === 'function') {
              return invoker(normalised, init);
            }
          } catch (_err) {
            // fall back to direct fetch when helper unavailable
          }
          return fetch(`/functions/v1/${normalised}`, init);
        };
      })();
    </script>
    <script>
      (function initialiseTwitterDebugFlags() {
        try {
          const params = new URLSearchParams(window.location.search);
          if (params.get('twdebug') === '1') {
            window.__TW_DEBUG__ = true;
          }
          if (window.__TW_DEBUG__ === true) {
            if (params.get('twforce') === '1') {
              window.__TW_FORCE__ = true;
              try {
                sessionStorage.setItem('__tw_force', '1');
              } catch (storageError) {
                if (window.__TW_DEBUG__ === true) {
                  console.warn('[Twitter Pixel] Unable to persist twforce flag', storageError);
                }
              }
            }
            try {
              if (sessionStorage.getItem('__tw_force') === '1') {
                window.__TW_FORCE__ = true;
              }
            } catch (storageError) {
              if (window.__TW_DEBUG__ === true) {
                console.warn('[Twitter Pixel] Unable to read twforce flag', storageError);
              }
            }
            if (window.__TW_FORCE__ === true) {
              console.warn('[Twitter Pixel] Consent override active via ?twforce=1');
            }
          }
        } catch (error) {
          if (window.__TW_DEBUG__ === true) {
            console.warn('[Twitter Pixel] Debug flag initialisation failed', error);
          }
        }
      })();
    </script>
    <script>
      (function guardRudderIdentify() {
        const REQUIRED_INTERVAL_MS = 500;

        function toStringOrEmpty(value) {
          return typeof value === 'string' ? value.trim() : '';
        }

        function hasRequiredTraits(traits) {
          if (!traits || typeof traits !== 'object') return false;
          const email = toStringOrEmpty(
            traits.email || traits.Email || traits.userEmail || traits.user_email,
          );
          const phone = toStringOrEmpty(
            traits.phone || traits.phone_number || traits.phoneNumber || traits.Phone,
          );
          const firstName = toStringOrEmpty(traits.firstName || traits.first_name || traits.FirstName);
          const lastName = toStringOrEmpty(traits.lastName || traits.last_name || traits.LastName);
          const postalCode = toStringOrEmpty(traits.postalCode || traits.postal_code || traits.zip);
          const country = toStringOrEmpty(traits.country || traits.Country);
          return Boolean(email && phone && (firstName || lastName || postalCode || country));
        }

        function wrapIdentify() {
          const ra = window.rudderanalytics;
          if (!ra || typeof ra.identify !== 'function' || ra.identify.__patched) {
            return false;
          }

          const original = ra.identify.bind(ra);
          ra.identify = function patchedIdentify() {
            const args = Array.from(arguments);
            const traitsCandidate = args.length > 1
              ? args[1]
              : (typeof args[0] === 'object' && args[0] !== null ? args[0] : undefined);

            if (!hasRequiredTraits(traitsCandidate)) {
              console.warn('rudderanalytics.identify skipped: missing required traits', traitsCandidate);
              return Promise.resolve(null);
            }

            try {
              const result = original.apply(this, args);
              if (result && typeof result.then === 'function') {
                return result.catch((err) => {
                  console.warn('rudderanalytics.identify suppressed error', err);
                  return null;
                });
              }
              return result;
            } catch (err) {
              console.warn('rudderanalytics.identify suppressed error', err);
              return Promise.resolve(null);
            }
          };
          ra.identify.__patched = true;
          return true;
        }

        if (!wrapIdentify()) {
          const timer = setInterval(() => {
            if (wrapIdentify()) {
              clearInterval(timer);
            }
          }, REQUIRED_INTERVAL_MS);
        }
      })();
    </script>
    <!-- Google Tag Manager -->
    <script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
    new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
    j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
    'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
    })(window,document,'script','dataLayer','GTM-M66MXTL9');</script>
    <!-- End Google Tag Manager -->

    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-J2XXMC9VWV"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'G-J2XXMC9VWV');
    </script>

    <!-- Meta Pixel (init) -->
    <script>
      !function(f,b,e,v,n,t,s)
      {if(f.fbq)return;n=f.fbq=function(){n.callMethod?
      n.callMethod.apply(n,arguments):n.queue.push(arguments)};
      if(!f._fbq)f._fbq=n;n.push=n;n.loaded=!0;n.version='2.0';
      n.queue=[];t=b.createElement(e);t.async=!0;
      t.src=v;s=b.getElementsByTagName(e)[0];
      s.parentNode.insertBefore(t,s)}(window, document,'script',
      'https://connect.facebook.net/en_US/fbevents.js');
      fbq('init', '1775596122750375');
    </script>
    <!-- End Meta Pixel (init) -->

    <!-- Meta Pixel helpers: unique event_id + fbclid + SPA route tracking -->
    <script>
      // RFC4122-ish UUID for event_id
      function convUUID(){
        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g,c=>{
          const r=(crypto.getRandomValues(new Uint8Array(1))[0]&15);
          const v=c==='x'?r:(r&0x3)|0x8; return v.toString(16);
        });
      }

      // Capture and persist fbclid from query params
      (function(){
        try {
          const params = new URLSearchParams(location.search);
          const cid = params.get('fbclid');
          if (cid) {
            localStorage.setItem('fb_click_id', cid);
          }
        } catch (e) {
          // no-op
        }
      })();

      function getFBClickId(){
        try { return localStorage.getItem('fb_click_id') || undefined; }
        catch { return undefined; }
      }

      // Wrapper to attach an eventID and fbc; returns the id we used
      const FB_LOG_DEV = (() => {
        try {
          const host = (window.location && window.location.hostname) || '';
          return host === 'localhost' || host === '127.0.0.1' || host.endsWith('.local');
        } catch (err) {
          console.warn('fbTrack host detection failed', err);
          return false;
        }
      })();

      function validateFbDpaPayload(eventName, props) {
        if (eventName !== 'AddToCart' && eventName !== 'Purchase') {
          return true;
        }

        const hasContents = Array.isArray(props.contents) && props.contents.length > 0;
        const hasContentIds = Array.isArray(props.content_ids) && props.content_ids.length > 0;
        if (!hasContents && !hasContentIds) {
          console.warn(`fbTrack ${eventName} skipped: missing contents/content_ids`, props);
          return false;
        }

        if (!props.content_type) {
          props.content_type = 'product';
        }

        if (eventName === 'Purchase') {
          if (typeof props.value !== 'number' || !Number.isFinite(props.value)) {
            console.warn(`fbTrack ${eventName} skipped: invalid value`, props);
            return false;
          }
          if (typeof props.currency !== 'string' || !props.currency.trim()) {
            console.warn(`fbTrack ${eventName} skipped: missing currency`, props);
            return false;
          }
        }

        return true;
      }

      function logFbPayload(eventName, props) {
        if (!FB_LOG_DEV) return;
        if (eventName !== 'AddToCart' && eventName !== 'Purchase') return;
        try {
          const snapshot = JSON.parse(JSON.stringify(props));
          console.debug(`[fbTrack:${eventName}]`, snapshot);
        } catch {
          console.debug(`[fbTrack:${eventName}]`, props);
        }
      }

      window.fbTrack = function(eventName, props){
        props = props || {};
        if (!props.eventID) props.eventID = convUUID();
        const clickId = props.fbc || getFBClickId();
        if (clickId) props.fbc = `fb.1.${Date.now()}.${clickId}`;

        if (!validateFbDpaPayload(eventName, props)) {
          return '';
        }

        logFbPayload(eventName, props);

        if (window.fbq) {
          if (eventName === 'Custom' && props.custom_event_name) {
            fbq('trackCustom', props.custom_event_name, props);
          } else {
            fbq('track', eventName, props);
          }
        }
        return props.eventID;
      };

      // Update advanced matching user signals after email capture
      window.fbSetUser = function(props){
        props = props || {};
        if (props.email && window.fbq) {
          fbq('init', '1775596122750375', { em: props.email });
        }
      };

      // Fire initial page view
      window.fbTrack('PageView');

      // SPA route tracking + business events
      (function(){
        function onRoute(){
          const path = (location.pathname || '').toLowerCase();

          // Assessment start
          if (path.startsWith('/assessment')) {
            window.fbTrack('ViewContent', { content_name: 'Assessment' });
          }
          // Completion (tune to your actual results/complete paths)
          if (path.includes('result') || path.includes('complete') || path.includes('done')) {
            window.fbTrack('Custom', { custom_event_name: 'AssessmentComplete' });
          }
          // Post-signup destinations
          if (
            path.startsWith('/signup/complete') ||
            path.startsWith('/welcome') ||
            path.includes('/account/create/complete')
          ) {
            window.fbTrack('CompleteRegistration');
          }
        }

        // initial load
        onRoute();

        // watch SPA nav
        ['pushState','replaceState'].forEach(method=>{
          const orig = history[method];
          history[method] = function(){
            const ret = orig.apply(this, arguments);
            setTimeout(()=>{ window.fbTrack('PageView'); onRoute(); }, 0);
            return ret;
          };
        });
        addEventListener('popstate', ()=>{ window.fbTrack('PageView'); onRoute(); });

        // Optional explicit app hooks
        addEventListener('app:assessment:complete', ()=> {
          window.fbTrack('Custom', { custom_event_name: 'AssessmentComplete' });
        });
        addEventListener('app:user:signup', ()=> {
          window.fbTrack('CompleteRegistration');
        });
      })();
    </script>
    <!-- End Meta Pixel helpers -->
    <!-- LinkedIn Insight Tag (init) -->
    <script type="text/javascript">
      _linkedin_partner_id = "7877778";
      window._linkedin_data_partner_ids = window._linkedin_data_partner_ids || [];
      window._linkedin_data_partner_ids.push(_linkedin_partner_id);
    </script>
    <script type="text/javascript">
      (function(l) {
        if (!l) {
          window.lintrk = function(a, b) { window.lintrk.q.push([a, b]); };
          window.lintrk.q = [];
        }
        var s = document.getElementsByTagName("script")[0];
        var b = document.createElement("script");
        b.type = "text/javascript"; b.async = true;
        b.src = "https://snap.licdn.com/li.lms-analytics/insight.min.js";
        s.parentNode.insertBefore(b, s);
      })(window.lintrk);
    </script>
    <!-- End LinkedIn Insight Tag (init) -->

    <!-- Quora Pixel Code (Base) -->
    <script>
      (function loadQuoraPixelBase() {
        var enable = "<%= import.meta.env.VITE_ENABLE_QUORA_PIXEL %>" === "true";
        var pidRaw = "<%= import.meta.env.VITE_QUORA_PIXEL_ID %>";
        var pid = typeof pidRaw === 'string' ? pidRaw.trim() : '';

        if (!enable || !pid || pid === 'undefined') {
          return;
        }

        (function (q, e, v, n, t, s) {
          if (q.qp) return;
          n = q.qp = function () {
            n.qp ? n.qp.apply(n, arguments) : n.queue.push(arguments);
          };
          n.queue = [];
          t = document.createElement(e);
          t.async = !0;
          t.src = v;
          s = document.getElementsByTagName(e)[0];
          s.parentNode.insertBefore(t, s);
        })(window, 'script', 'https://a.quora.com/qevents.js');
        qp('init', pid);
        qp('track', 'ViewContent');
      })();
    </script>
    <!-- End of Quora Pixel Code -->
    <script>
      (function(){
        function readPixelId(){
          try {
            const config = window.__APP_CONFIG__;
            if (config && typeof config.QUORA_PIXEL_ID === 'string') {
              const trimmed = config.QUORA_PIXEL_ID.trim();
              if (trimmed) return trimmed;
            }
          } catch (_) {}
          return undefined;
        }

        const configuredPixelId = readPixelId();
        const PIXEL_ID = configuredPixelId || undefined;
        const RESULTS_RE = /\/results(\/|$)/i;
        const ALLOW_RESULTS_FLAG = '__allowResults';
        const DEBUG = /\bqdebug=1\b/.test(location.search);
        let configured = false, lastError = null;

        function hasAnalyticsConsent(){
          try {
            const c = window.__consent;
            return !!(c && c.analytics === true);
          } catch (e) { return false; }
        }

        function initQuora(email){
          try {
            if (!PIXEL_ID) {
              if (DEBUG) console.warn('[Quora] disabled – no QUORA_PIXEL_ID configured');
              return;
            }
            if (configured || !window.qp) return;
            if (email) { qp('init', PIXEL_ID, { email: email }); }
            else { qp('init', PIXEL_ID); }
            configured = true;
            if (DEBUG) console.info('[Quora] configured', { email: !!email });
          } catch (e) { lastError = e; if (DEBUG) console.warn('[Quora] init error', e); }
        }

        // Defer init until consent is granted
        function tryConfigure(){
          if (configured) return true;
          if (!PIXEL_ID) return false;
          if (!hasAnalyticsConsent() || typeof window.qp !== 'function') return false;
          // Optionally pass known email for advanced matching (hashed by Quora)
          const knownEmail = (window.__knownUser && window.__knownUser.email) || undefined;
          initQuora(knownEmail);
          return configured;
        }

        // Poll briefly; also listen for consent changes
        let attempts = 0, timer = setInterval(function(){
          attempts++; if (tryConfigure() || attempts > 40) clearInterval(timer);
        }, 500);
        ['consent:updated','app:consent:updated','consentchange'].forEach(evt=>{
          addEventListener(evt, tryConfigure, { passive:true });
        });

        function uuid(){
          if (crypto && crypto.randomUUID) return crypto.randomUUID();
          return (Date.now().toString(36)+'-'+Math.random().toString(36).slice(2));
        }

        function invokeCapi(eventName, payload){
          if (!payload || !payload.conversion_id || !hasAnalyticsConsent()) return;
          const body = {
            event_name: eventName,
            conversion_id: payload.conversion_id,
            value: typeof payload.value === 'number' ? payload.value : undefined,
            currency: typeof payload.currency === 'string' ? payload.currency : undefined,
            email: typeof payload.email === 'string' ? payload.email : undefined,
            contents: Array.isArray(payload.contents) ? payload.contents : undefined,
            content_ids: Array.isArray(payload.content_ids) ? payload.content_ids : undefined,
            event_time: Math.floor(Date.now() / 1000),
            user_agent: navigator.userAgent,
          };
          if (window.__knownUser && typeof window.__knownUser.email === 'string' && !body.email) {
            body.email = window.__knownUser.email;
          }
          const requestInit = {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'x-consent-analytics': hasAnalyticsConsent() ? 'true' : 'false',
            },
            body: JSON.stringify(body),
            keepalive: true,
          };
          try {
            const invoke = window.__supabaseFunctionFetch;
            if (typeof invoke === 'function') {
              invoke('quora-capi', requestInit).catch(() => {});
            } else {
              fetch('/functions/v1/quora-capi', requestInit).catch(() => {});
            }
          } catch (err) {
            if (DEBUG) console.warn('[Quora] CAPI error', err);
          }
        }

        window.qpTrack = function(eventName, props){
          if (!configured) { if (DEBUG) console.info('[Quora] drop (not configured)', eventName); return; }
          const payload = Object.assign({}, props || {});
          const allowOnResults = !!payload[ALLOW_RESULTS_FLAG];
          if (ALLOW_RESULTS_FLAG in payload) delete payload[ALLOW_RESULTS_FLAG];

          if (RESULTS_RE.test(location.pathname) && eventName !== 'ViewContent' && !allowOnResults){
            if (DEBUG) console.info('[Quora] suppressed on /results', eventName);
            return;
          }
          if (!payload.conversion_id) payload.conversion_id = uuid();
          try {
            qp('track', eventName, payload);
            if (payload.conversion_id) {
              try { window.__lastQuoraConversionId = payload.conversion_id; } catch (_) {}
            }
            invokeCapi(eventName, payload);
            if (DEBUG) console.info('[Quora] track', eventName, payload);
            return payload.conversion_id;
          } catch (e) { lastError = e; if (DEBUG) console.warn('[Quora] track error', e); }
        };

        // Debug helpers
        window.__QW_STATUS__ = function(){
          return {
            configured, hasTwqLike:false, // placeholder parity
            consent: hasAnalyticsConsent(),
            path: location.pathname, lastError
          };
        };
        window.qpTest = function(){
          return window.qpTrack('GenerateLead', { test:true });
        };
      })();
    </script>
    <!-- Reddit Pixel (init) -->
    <script>
      !function(w,d){if(!w.rdt){var p=w.rdt=function(){p.sendEvent?p.sendEvent.apply(p,arguments):p.callQueue.push(arguments)};p.callQueue=[];
      var t=d.createElement("script");t.src="https://www.redditstatic.com/ads/pixel.js";t.async=!0;
      var s=d.getElementsByTagName("script")[0];s.parentNode.insertBefore(t,s)}}(window,document);
      // Use configurable pixel ID from app config or fallback
      const redditPixelId = (window.__APP_CONFIG__ && window.__APP_CONFIG__.REDDIT_PIXEL_ID) || 'a2_hisg7r10d2ta';
      rdt('init', redditPixelId);
    </script>
    <!-- End Reddit Pixel (init) -->

    <!-- Reddit Pixel helpers: unique conversion_id + click_id + SPA route tracking -->
    <script>
      // RFC4122-ish UUID for conversion_id
      function convUUID(){
        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g,c=>{
          const r=(crypto.getRandomValues(new Uint8Array(1))[0]&15);
          const v=c==='x'?r:(r&0x3)|0x8; return v.toString(16);
        });
      }

      // Capture and persist Reddit click IDs from query params
      (function(){
        try {
          const params = new URLSearchParams(location.search);
          const cid = params.get('rdt_cid');
          if (cid) {
            localStorage.setItem('rdt_click_id', cid);
          }
        } catch (e) {
          // no-op
        }
      })();

      function getClickId(){
        try { return localStorage.getItem('rdt_click_id') || undefined; }
        catch { return undefined; }
      }

      let redditCustomNameWarned = false;

      // Wrapper to always attach a conversion_id and click_id; returns the id we used
        window.rdtTrack = function(eventName, props){
          props = props || {};
          if (eventName === 'Custom') {
            const customName = props.custom_event_name || props.customEventName || props.name;
            if (!customName) {
              if (!redditCustomNameWarned) {
                redditCustomNameWarned = true;
                console.warn('Reddit Custom event skipped: missing custom event name', props);
              }
              return '';
            }
            props.custom_event_name = customName;
            props.customEventName = customName;
          }
          if (!props.conversion_id) props.conversion_id = convUUID();
          const clickId = props.click_id || getClickId();
          if (clickId) props.click_id = clickId;
          if (props.email && window.redditNormalizeEmail) {
            props.email = window.redditNormalizeEmail(props.email);
          }
          if (window.rdt) rdt('track', eventName, props);
          const customName = eventName === 'Custom' ? props.custom_event_name : undefined;
          const requestBody = {
            event_name: customName || eventName,
            event_type: eventName,
            conversion_id: props.conversion_id,
            click_id: props.click_id,
            email: props.email,
            ...(customName ? { custom_event_name: customName } : {}),
          };
          const requestInit = {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(requestBody),
            keepalive: true,
          };
          try {
            const promise = window.__invokeSupabaseEdge && window.__invokeSupabaseEdge('reddit-capi', requestInit);
            if (promise && typeof promise.catch === 'function') {
              promise.catch(() => {});
            }
          } catch (e) {
            // no-op
          }
          window.__lastConversionId = props.conversion_id; // for CAPI dedup
          return props.conversion_id;
        };

      // Update advanced matching user signals after email capture
      window.rdtSetUser = function(props){
        props = props || {};
        if (props.email && window.redditNormalizeEmail) {
          props.email = window.redditNormalizeEmail(props.email);
        }
        const pixelId = (window.__APP_CONFIG__ && window.__APP_CONFIG__.REDDIT_PIXEL_ID) || 'a2_hisg7r10d2ta';
        if (window.rdt) rdt('init', pixelId, props);
      };

      // Fire initial page view
      window.rdtTrack('PageVisit');

      // SPA route tracking + business events
      (function(){
        function onRoute(){
          window.rdtTrack('PageVisit');

          const path = (location.pathname || '').toLowerCase();

          // Assessment start
          if (path.startsWith('/assessment')) {
            window.rdtTrack('ViewContent', { content_name: 'Assessment' });
          }
          // Completion (tune to your actual results/complete paths)
          if (path.includes('result') || path.includes('complete') || path.includes('done')) {
            window.rdtTrack('Custom', { custom_event_name: 'AssessmentComplete' });
          }
          // Post-signup destinations
          if (
            path.startsWith('/signup/complete') ||
            path.startsWith('/welcome') ||
            path.includes('/account/create/complete')
          ) {
            window.rdtTrack('SignUp');
          }
        }

        // initial load
        onRoute();

        // watch SPA nav
        ['pushState','replaceState'].forEach(method=>{
          const orig = history[method];
          history[method] = function(){
            const ret = orig.apply(this, arguments);
            setTimeout(onRoute, 0);
            return ret;
          };
        });
        addEventListener('popstate', onRoute);

        // Optional explicit app hooks
        addEventListener('app:assessment:complete', ()=> {
          window.rdtTrack('Custom', { custom_event_name: 'AssessmentComplete' });
        });
        addEventListener('app:user:signup', ()=> {
          window.rdtTrack('SignUp');
        });
      })();
    </script>
    <!-- End Reddit helpers -->

    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>PRISM Dynamics™ — Model, Methods, and Confidence— Model, Methods, and Confidence</title>
    <meta name="description" content="Learn how PRISM Dynamics™ — Model, Methods, and Confidence (Personality, Regulation, Information, System Mapping) measures information elements, dimensionality (1D–4D), block dynamics, and a ± overlay, using multi-method items and confidence-based scoring.">
    <meta name="author" content="PRISM Personality System" />
    <link rel="icon" href="/lovable-uploads/5e9af605-c408-4bf3-ac7d-7d379b09af9b.png" type="image/png">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

    
    
    <meta property="og:type" content="website" />
    <meta property="og:image" content="https://storage.googleapis.com/gpt-engineer-file-uploads/G3Sz2fKo71NconcX3jqdgxPMO9g1/social-images/social-1759176214884-ChatGPT Image Sep 29, 2025, 03_27_27 PM.png">

    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:site" content="@prism_personality" />
    <meta name="twitter:image" content="https://storage.googleapis.com/gpt-engineer-file-uploads/G3Sz2fKo71NconcX3jqdgxPMO9g1/social-images/social-1759176214884-ChatGPT Image Sep 29, 2025, 03_27_27 PM.png">

    <!-- Twitter Pixel (base loader) -->
    <script>
      !(function(w, d, s, u, a, b) {
        const debug = w.__TW_DEBUG__ === true;
        if (w.twq) {
          if (debug) {
            console.info('[Twitter Pixel] twq stub already present');
          }
          return;
        }
        u = w.twq = function() {
          if (u.exe) {
            u.exe.apply(u, arguments);
          } else {
            u.queue.push(arguments);
          }
        };
        u.version = '1.1';
        u.queue = [];
        a = d.createElement(s);
        a.async = true;
        a.src = 'https://static.ads-twitter.com/uwt.js';
        if (debug) {
          console.info('[Twitter Pixel] Loader stub defined; requesting uwt.js', { src: a.src });
          a.addEventListener('load', () => {
            console.info('[Twitter Pixel] uwt.js loaded');
          });
          a.addEventListener('error', (event) => {
            console.error('[Twitter Pixel] Failed to load uwt.js', event);
            w.__TW_LAST_ERROR__ = 'Failed to load uwt.js';
          });
        }
        b = d.getElementsByTagName(s)[0];
        b.parentNode.insertBefore(a, b);
      })(window, document, 'script');
    </script>
    <!-- End Twitter Pixel (base loader) -->

    <!-- Twitter Pixel helpers: consent, dedupe, and results-page safety -->
    <script>
      (function configureTwitterPixel() {
        const PIXEL_ID = 'nwcm8';
        const ALLOW_RESULTS_FLAG = '__allowResults';
        const RESULTS_PATH_PATTERN = /\/results(\/|$)/i;
        const CONSENT_CHECK_INTERVAL = 500;
        const MAX_CONSENT_CHECKS = 40;
        const debug = window.__TW_DEBUG__ === true;
        const forceOverride = window.__TW_FORCE__ === true;
        let configured = false;
        let lastError = window.__TW_LAST_ERROR__ || null;
        let lastConfigFailure = null;
        let cmpAnalyticsConsent = null;
        let tcfAnalyticsConsent = null;
        let cspProbeResult = 'pending';
        let cspProbeAttempted = false;
        let cmpListenerRegistered = false;
        let tcfListenerRegistered = false;
        let cmpLastPoll = 0;
        let tcfLastPoll = 0;
        const CMP_POLL_INTERVAL = 5000;
        const TCF_POLL_INTERVAL = 5000;

        if (debug) {
          console.info(
            '[Twitter Pixel] Required CSP domains (img-src & connect-src): static.ads-twitter.com, ads-twitter.com, ads-api.twitter.com, analytics.twitter.com, t.co',
          );
        }

        function debugLog(level, message, payload) {
          if (!debug) return;
          const logger = typeof console[level] === 'function' ? console[level] : console.log;
          if (payload !== undefined) {
            logger.call(console, `[Twitter Pixel] ${message}`, payload);
          } else {
            logger.call(console, `[Twitter Pixel] ${message}`);
          }
        }

        function setLastError(message) {
          lastError = message;
          if (message) {
            window.__TW_LAST_ERROR__ = message;
          } else {
            delete window.__TW_LAST_ERROR__;
          }
        }

        function interpretConsentValue(value) {
          if (value === null || value === undefined) return null;
          if (typeof value === 'boolean') return value;
          if (typeof value === 'number') return value === 1;
          if (typeof value === 'string') {
            const normalized = value.toLowerCase();
            if (['granted', 'true', '1', 'allow', 'allowed', 'accepted', 'consent', 'yes', 'on'].includes(normalized)) {
              return true;
            }
            if (['denied', 'declined', 'false', '0', 'refused', 'revoked', 'no', 'off'].includes(normalized)) {
              return false;
            }
          }
          return null;
        }

        function evaluateConsentFromObject(source) {
          if (!source || typeof source !== 'object') return null;
          const keys = [
            'analytics',
            'Analytics',
            'statistics',
            'Statistics',
            'performance',
            'Performance',
            'measurement',
            'Measurement',
            'consentAnalytics',
            'analyticsConsent',
            'measurementConsent',
          ];
          for (const key of keys) {
            if (key in source) {
              const interpreted = interpretConsentValue(source[key]);
              if (interpreted !== null) return interpreted;
            }
          }
          const categoryArrays = [
            source.categories,
            source.allowedCategories,
            source.acceptedCategories,
            source.grantedCategories,
            source.enabled,
            source.enabledCategories,
          ];
          const acceptedValues = ['analytics', 'measurement', 'statistics', 'performance'];
          for (const arrayCandidate of categoryArrays) {
            if (Array.isArray(arrayCandidate)) {
              if (arrayCandidate.some((value) => typeof value === 'string' && acceptedValues.includes(value.toLowerCase()))) {
                return true;
              }
            }
          }
          return null;
        }

        function evaluateCmpResult(result) {
          if (!result || typeof result !== 'object') return null;
          const direct = evaluateConsentFromObject(result);
          if (direct !== null) return direct;
          const purposeConsents = result.purposeConsents || result.purposes || result.purpose || result.categories;
          if (purposeConsents && typeof purposeConsents === 'object') {
            const purposeKeys = ['analytics', 'measurement', 'statistics', 'performance', '7', '8', '9', '10'];
            for (const key of purposeKeys) {
              if (key in purposeConsents) {
                const interpreted = interpretConsentValue(purposeConsents[key]);
                if (interpreted !== null) return interpreted;
              }
            }
          }
          return null;
        }

        function evaluateTcData(tcData) {
          if (!tcData || typeof tcData !== 'object') return null;
          const direct = evaluateConsentFromObject(tcData);
          if (direct !== null) return direct;
          const consents = tcData.purpose && tcData.purpose.consents;
          if (consents && typeof consents === 'object') {
            const purposeKeys = ['7', '8', '9', '10'];
            for (const key of purposeKeys) {
              if (key in consents) {
                const interpreted = interpretConsentValue(consents[key]);
                if (interpreted !== null) return interpreted;
              }
            }
          }
          if (tcData.specialFeatureOptins && typeof tcData.specialFeatureOptins === 'object') {
            const measurementOptIn = interpretConsentValue(tcData.specialFeatureOptins['1']);
            if (measurementOptIn !== null) return measurementOptIn;
          }
          return null;
        }

        function refreshCmpConsent() {
          const cmp = window.__cmp;
          if (typeof cmp !== 'function') return;
          const now = Date.now();
          if (cmpAnalyticsConsent === null || now - cmpLastPoll >= CMP_POLL_INTERVAL) {
            cmpLastPoll = now;
            try {
              cmp('getConsentState', null, (result, success) => {
                if (!success) return;
                const interpreted = evaluateCmpResult(result);
                if (interpreted !== null) {
                  cmpAnalyticsConsent = interpreted;
                  debugLog('info', 'CMP analytics consent updated', { source: 'getConsentState', value: interpreted });
                  ensureConfigured('cmp-getConsentState');
                }
              });
            } catch (error) {
              debugLog('warn', 'CMP getConsentState failed', error);
            }
          }
          if (!cmpListenerRegistered) {
            try {
              cmp('addEventListener', null, (event) => {
                if (!event) return;
                const interpreted = evaluateCmpResult(event);
                if (interpreted !== null) {
                  cmpAnalyticsConsent = interpreted;
                  debugLog('info', 'CMP analytics consent event', { value: interpreted });
                  ensureConfigured('cmp-event');
                }
              });
              cmpListenerRegistered = true;
            } catch (error) {
              cmpListenerRegistered = false;
              debugLog('debug', 'CMP addEventListener unavailable', error);
            }
          }
        }

        function refreshTcfConsent() {
          const tcfapi = window.__tcfapi;
          if (typeof tcfapi !== 'function') return;
          const now = Date.now();
          if (tcfAnalyticsConsent === null || now - tcfLastPoll >= TCF_POLL_INTERVAL) {
            tcfLastPoll = now;
            try {
              tcfapi('getTCData', 2, (tcData, success) => {
                if (!success) return;
                const interpreted = evaluateTcData(tcData);
                if (interpreted !== null) {
                  tcfAnalyticsConsent = interpreted;
                  debugLog('info', 'TCF analytics consent updated', { source: 'getTCData', value: interpreted });
                  ensureConfigured('tcf-getTCData');
                }
              });
            } catch (error) {
              debugLog('warn', 'TCF getTCData failed', error);
            }
          }
          if (!tcfListenerRegistered) {
            try {
              tcfapi('addEventListener', 2, (tcData, success) => {
                if (!success) return;
                const interpreted = evaluateTcData(tcData);
                if (interpreted !== null) {
                  tcfAnalyticsConsent = interpreted;
                  debugLog('info', 'TCF analytics consent event', { value: interpreted, eventStatus: tcData && tcData.eventStatus });
                  ensureConfigured('tcf-event');
                }
              });
              tcfListenerRegistered = true;
            } catch (error) {
              tcfListenerRegistered = false;
              debugLog('debug', 'TCF addEventListener unavailable', error);
            }
          }
        }

        function sanitisePayloadForLog(payload) {
          if (!payload || typeof payload !== 'object') return payload;
          const clone = Object.assign({}, payload);
          if ('email_address' in clone) clone.email_address = '[redacted]';
          if ('email' in clone) clone.email = '[redacted]';
          if ('phone_number' in clone) clone.phone_number = '[redacted]';
          if ('phone' in clone) clone.phone = '[redacted]';
          return clone;
        }

        function refreshConsentSignals() {
          refreshCmpConsent();
          refreshTcfConsent();
        }

        function hasAnalyticsConsent() {
          if (forceOverride) return true;
          const direct = evaluateConsentFromObject(window.__consent);
          if (direct !== null) return direct;
          if (cmpAnalyticsConsent !== null) return cmpAnalyticsConsent;
          if (tcfAnalyticsConsent !== null) return tcfAnalyticsConsent;
          return false;
        }

        function recordFailure(message, detail) {
          setLastError(message);
          if (!debug) return;
          if (lastConfigFailure !== message) {
            console.warn('[Twitter Pixel]', message, detail || undefined);
          }
          lastConfigFailure = message;
        }

        function clearFailures() {
          setLastError(null);
          lastConfigFailure = null;
        }

        function logDebugSummary(stage) {
          if (!debug) return;
          const status = {
            hasTwq: typeof window.twq === 'function',
            configured,
            consent: hasAnalyticsConsent(),
            pathname: window.location.pathname,
            csp: cspProbeResult,
          };
          console.groupCollapsed('[Twitter Pixel] Debug summary');
          console.log(`Stage: ${stage}`);
          console.table([status]);
          console.log(`${status.hasTwq ? '✅' : '❌'} hasTwq`);
          console.log(`${status.configured ? '✅' : '❌'} configured`);
          console.log(`${status.consent ? '✅' : '❌'} consent`);
          const cspIndicator = status.csp === 'ok' ? '✅' : status.csp === 'blocked' ? '❌' : '⚠️';
          console.log(`${cspIndicator} CSP (${status.csp})`);
          console.log(`Path: ${status.pathname}`);
          if (lastError) {
            console.log('Last error:', lastError);
          }
          console.groupEnd();
        }

        function ensureConfigured(context) {
          if (configured) return true;
          if (!hasAnalyticsConsent()) {
            recordFailure('Waiting for analytics consent', { context });
            return false;
          }
          if (typeof window.twq !== 'function') {
            recordFailure('Twitter Pixel loader not ready', { context });
            return false;
          }
          try {
            debugLog('info', `Configuring Twitter Pixel (${PIXEL_ID})`, { context, forceOverride });
            window.twq('config', PIXEL_ID, { use_1p: true });
            configured = true;
            clearFailures();
            debugLog('info', 'Twitter Pixel configured', { context });
            logDebugSummary('configured');
            return true;
          } catch (error) {
            recordFailure('Twitter Pixel configuration error', error);
            return false;
          }
        }

        function scheduleConsentChecks() {
          let attempts = 0;
          const timer = window.setInterval(() => {
            attempts += 1;
            refreshConsentSignals();
            if (ensureConfigured('consent-interval') || attempts >= MAX_CONSENT_CHECKS) {
              window.clearInterval(timer);
            }
          }, CONSENT_CHECK_INTERVAL);
        }

        function captureTwclid() {
          try {
            const params = new URLSearchParams(window.location.search);
            const clickId = params.get('twclid');
            if (clickId) {
              localStorage.setItem('twclid', clickId);
              debugLog('info', 'Captured twclid', { clickId });
            }
          } catch (error) {
            debugLog('warn', 'Twitter Pixel click id capture failed (non-blocking)', error);
          }
        }

        function getStoredTwclid() {
          try {
            return localStorage.getItem('twclid') || undefined;
          } catch (error) {
            debugLog('debug', 'Unable to access stored twclid', error);
            return undefined;
          }
        }

        function generateConversionId() {
          try {
            return crypto.randomUUID();
          } catch (error) {
            debugLog('debug', 'crypto.randomUUID unavailable, using fallback', error);
            return `${Date.now().toString(36)}-${Math.random().toString(36).slice(2)}`;
          }
        }

        function attachConsentListeners() {
          const events = ['consent:updated', 'app:consent:updated', 'consentchange'];
          events.forEach((eventName) => {
            if (typeof window.addEventListener === 'function') {
              window.addEventListener(
                eventName,
                () => {
                  refreshConsentSignals();
                  ensureConfigured(`event:${eventName}`);
                },
                { passive: true },
              );
            }
            if (typeof document.addEventListener === 'function') {
              document.addEventListener(
                eventName,
                () => {
                  refreshConsentSignals();
                  ensureConfigured(`event:${eventName}`);
                },
                { passive: true },
              );
            }
          });
        }

        function runCspProbe() {
          if (!debug || typeof fetch !== 'function' || cspProbeAttempted) return;
          cspProbeAttempted = true;
          fetch('https://static.ads-twitter.com/uwt.js', { mode: 'no-cors', cache: 'no-store' })
            .then(() => {
              cspProbeResult = 'ok';
              debugLog('info', 'CSP probe succeeded');
              logDebugSummary('csp-ok');
            })
            .catch((error) => {
              cspProbeResult = 'blocked';
              recordFailure('Twitter Pixel loader blocked (CSP or network)', error);
              console.error(
                '[Twitter Pixel] uwt.js fetch failed. Ensure CSP allows static.ads-twitter.com, ads-twitter.com, ads-api.twitter.com, analytics.twitter.com, and t.co in both img-src and connect-src.',
              );
              logDebugSummary('csp-error');
            });
        }

        window.__twStatus = function __twStatus() {
          return {
            hasTwq: typeof window.twq === 'function',
            configured,
            consent: hasAnalyticsConsent(),
            path: window.location.pathname,
            lastError: lastError || null,
            csp: cspProbeResult,
          };
        };

        window.twqTrack = function twqTrack(eventName, properties) {
          refreshConsentSignals();
          const hasConsent = hasAnalyticsConsent();
          if (!ensureConfigured(`track:${eventName}`)) {
            if (debug) {
              const reason = hasConsent ? 'pixel not ready' : 'missing consent';
              debugLog('info', `Dropping ${eventName} event (${reason})`, {
                event: eventName,
                path: window.location.pathname,
              });
            }
            return undefined;
          }

          const payload = Object.assign({}, properties);
          const allowOnResults = Boolean(payload && payload[ALLOW_RESULTS_FLAG]);
          if (payload && ALLOW_RESULTS_FLAG in payload) {
            delete payload[ALLOW_RESULTS_FLAG];
          }

          const onResultsRoute = RESULTS_PATH_PATTERN.test(window.location.pathname || '');
          if (onResultsRoute && eventName !== 'PageView' && !allowOnResults) {
            recordFailure('Event suppressed on results route');
            if (debug) {
              debugLog('info', `Dropping ${eventName} on results route`, {
                path: window.location.pathname,
              });
            }
            return undefined;
          }

          if (!payload.conversion_id) {
            payload.conversion_id = generateConversionId();
          }

          if (!payload.twclid) {
            const storedClickId = getStoredTwclid();
            if (storedClickId) payload.twclid = storedClickId;
          }

          try {
            window.twq('track', eventName, payload);
            clearFailures();
            if (debug) {
              debugLog('info', `Sent ${eventName}`, {
                payload: sanitisePayloadForLog(payload),
              });
            }
          } catch (error) {
            recordFailure('Twitter Pixel track error', error);
          }

          return payload.conversion_id;
        };

        if (debug) {
          window.twqTest = function twqTest() {
            const conversionId = window.twqTrack
              ? window.twqTrack('Lead', { test: true, [ALLOW_RESULTS_FLAG]: true })
              : undefined;
            debugLog('info', 'twqTest invoked', { conversionId });
            return conversionId;
          };
        } else if ('twqTest' in window) {
          try {
            delete window.twqTest;
          } catch (error) {
            // no-op if delete fails
          }
        }

        captureTwclid();
        attachConsentListeners();
        refreshConsentSignals();
        if (!ensureConfigured('initial')) {
          scheduleConsentChecks();
        }
        logDebugSummary('init');
        runCspProbe();
      })();
    </script>
    <!-- End Twitter Pixel helpers -->
    
  
  
  
  <meta property="og:title" content="PRISM Dynamics™ — Model, Methods, and Confidence— Model, Methods, and Confidence">
  <meta name="twitter:title" content="PRISM Dynamics™ — Model, Methods, and Confidence— Model, Methods, and Confidence">
  <meta property="og:description" content="Learn how PRISM Dynamics™ — Model, Methods, and Confidence (Personality, Regulation, Information, System Mapping) measures information elements, dimensionality (1D–4D), block dynamics, and a ± overlay, using multi-method items and confidence-based scoring.">
  <meta name="twitter:description" content="Learn how PRISM Dynamics™ — Model, Methods, and Confidence (Personality, Regulation, Information, System Mapping) measures information elements, dimensionality (1D–4D), block dynamics, and a ± overlay, using multi-method items and confidence-based scoring.">
</head>

  <body>
    <!-- Google Tag Manager (noscript) -->
    <noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-M66MXTL9"
    height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
    <!-- End Google Tag Manager (noscript) -->

    <!-- LinkedIn Insight Tag noscript fallback -->
    <noscript>
      <img height="1" width="1" style="display:none;" alt=""
        src="https://px.ads.linkedin.com/collect/?pid=7877778&fmt=gif" />
    </noscript>

    <!-- Reddit Pixel noscript fallback -->
    <noscript>
      <img height="1" width="1" style="display:none" src="https://www.reddit.com/tr?id=a2_hisg7r10d2ta&ev=PageVisit&noscript=1">
    </noscript>

    <!-- Twitter Pixel noscript fallback -->
    <noscript>
      <img
        height="1"
        width="1"
        style="display:none"
        alt=""
        src="https://analytics.twitter.com/i/adsct?txn_id=nwcm8&p_id=Twitter&tw_sale_amount=0&tw_order_quantity=0"
      />
      <img
        height="1"
        width="1"
        style="display:none"
        alt=""
        src="https://t.co/i/adsct?txn_id=nwcm8&p_id=Twitter&tw_sale_amount=0&tw_order_quantity=0"
      />
    </noscript>

    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>
