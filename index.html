<!DOCTYPE html>
<html lang="en">
  <head>
    <!-- Disable Attribution Reporting API to avoid third-party attestation errors (e.g., Facebook Pixel) -->
    <meta http-equiv="Permissions-Policy" content="attribution-reporting=()" />
    <script>
      (function configureSupabase() {
        const existing = window.__APP_CONFIG__ || {};
        const defaultConfig = {
          SUPABASE_URL: "https://gnkuikentdtnatazeriu.supabase.co",
          SUPABASE_ANON_KEY: "sb_publishable_Yu_Gv0Xfve27udk78CyT3w_qrbMR3Cn",
          REDDIT_PIXEL_ID: "a2_hisg7r10d2ta", // Default Reddit Pixel ID
        };
        const config = Object.assign({}, defaultConfig, existing);

        const normaliseUrl = (value) =>
          typeof value === 'string' ? value.replace(/\/+$/, '') : undefined;

        const supabaseUrl = normaliseUrl(config.SUPABASE_URL);
        const configuredFunctionsUrl = normaliseUrl(config.SUPABASE_FUNCTION_URL);
        const functionsUrl = configuredFunctionsUrl
          || (supabaseUrl && supabaseUrl.includes('.supabase.co')
            ? supabaseUrl.replace('.supabase.co', '.functions.supabase.co')
            : undefined);

        if (functionsUrl) {
          config.SUPABASE_FUNCTION_URL = functionsUrl;
        }

        window.__APP_CONFIG__ = config;

        const anonKey = config.SUPABASE_ANON_KEY;

        function normaliseFunctionPath(path) {
          const trimmed = path.replace(/^\/+/, '');
          return trimmed.startsWith('functions/v1/')
            ? trimmed.slice('functions/v1/'.length)
            : trimmed;
        }

        window.__supabaseFunctionFetch = function(path, init) {
          if (!functionsUrl) {
            return Promise.reject(new Error('Supabase functions URL is not configured'));
          }

          const target = typeof path === 'string' && /^https?:/i.test(path)
            ? path
            : `${functionsUrl}/${normaliseFunctionPath(typeof path === 'string' ? path : '')}`;

          const requestInit = Object.assign({}, init);
          const headerBag = new Headers(requestInit.headers || {});

          if (anonKey) {
            if (!headerBag.has('apikey')) headerBag.set('apikey', anonKey);
            if (!headerBag.has('Authorization')) headerBag.set('Authorization', `Bearer ${anonKey}`);
          }

          requestInit.headers = headerBag;
          return fetch(target, requestInit);
        };
      })();
    </script>
    <script>
      (function initialiseTwitterDebugFlags() {
        try {
          const params = new URLSearchParams(window.location.search);
          if (params.get('twdebug') === '1') {
            window.__TW_DEBUG__ = true;
          }
          if (window.__TW_DEBUG__ === true) {
            if (params.get('twforce') === '1') {
              window.__TW_FORCE__ = true;
              try {
                sessionStorage.setItem('__tw_force', '1');
              } catch (storageError) {
                if (window.__TW_DEBUG__ === true) {
                  console.warn('[Twitter Pixel] Unable to persist twforce flag', storageError);
                }
              }
            }
            try {
              if (sessionStorage.getItem('__tw_force') === '1') {
                window.__TW_FORCE__ = true;
              }
            } catch (storageError) {
              if (window.__TW_DEBUG__ === true) {
                console.warn('[Twitter Pixel] Unable to read twforce flag', storageError);
              }
            }
            if (window.__TW_FORCE__ === true) {
              console.warn('[Twitter Pixel] Consent override active via ?twforce=1');
            }
          }
        } catch (error) {
          if (window.__TW_DEBUG__ === true) {
            console.warn('[Twitter Pixel] Debug flag initialisation failed', error);
          }
        }
      })();
    </script>
    <script>
      (function guardRudderIdentify() {
        const REQUIRED_INTERVAL_MS = 500;

        function toStringOrEmpty(value) {
          return typeof value === 'string' ? value.trim() : '';
        }

        function hasRequiredTraits(traits) {
          if (!traits || typeof traits !== 'object') return false;
          const email = toStringOrEmpty(
            traits.email || traits.Email || traits.userEmail || traits.user_email,
          );
          const phone = toStringOrEmpty(
            traits.phone || traits.phone_number || traits.phoneNumber || traits.Phone,
          );
          const firstName = toStringOrEmpty(traits.firstName || traits.first_name || traits.FirstName);
          const lastName = toStringOrEmpty(traits.lastName || traits.last_name || traits.LastName);
          const postalCode = toStringOrEmpty(traits.postalCode || traits.postal_code || traits.zip);
          const country = toStringOrEmpty(traits.country || traits.Country);
          return Boolean(email && phone && (firstName || lastName || postalCode || country));
        }

        function wrapIdentify() {
          const ra = window.rudderanalytics;
          if (!ra || typeof ra.identify !== 'function' || ra.identify.__patched) {
            return false;
          }

          const original = ra.identify.bind(ra);
          ra.identify = function patchedIdentify() {
            const args = Array.from(arguments);
            const traitsCandidate = args.length > 1
              ? args[1]
              : (typeof args[0] === 'object' && args[0] !== null ? args[0] : undefined);

            if (!hasRequiredTraits(traitsCandidate)) {
              console.warn('rudderanalytics.identify skipped: missing required traits', traitsCandidate);
              return Promise.resolve(null);
            }

            try {
              const result = original.apply(this, args);
              if (result && typeof result.then === 'function') {
                return result.catch((err) => {
                  console.warn('rudderanalytics.identify suppressed error', err);
                  return null;
                });
              }
              return result;
            } catch (err) {
              console.warn('rudderanalytics.identify suppressed error', err);
              return Promise.resolve(null);
            }
          };
          ra.identify.__patched = true;
          return true;
        }

        if (!wrapIdentify()) {
          const timer = setInterval(() => {
            if (wrapIdentify()) {
              clearInterval(timer);
            }
          }, REQUIRED_INTERVAL_MS);
        }
      })();
    </script>
    <!-- Google Tag Manager -->
    <script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
    new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
    j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
    'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
    })(window,document,'script','dataLayer','GTM-M66MXTL9');</script>
    <!-- End Google Tag Manager -->

    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-J2XXMC9VWV"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'G-J2XXMC9VWV');
    </script>

    <!-- Meta Pixel (init) -->
    <script>
      !function(f,b,e,v,n,t,s)
      {if(f.fbq)return;n=f.fbq=function(){n.callMethod?
      n.callMethod.apply(n,arguments):n.queue.push(arguments)};
      if(!f._fbq)f._fbq=n;n.push=n;n.loaded=!0;n.version='2.0';
      n.queue=[];t=b.createElement(e);t.async=!0;
      t.src=v;s=b.getElementsByTagName(e)[0];
      s.parentNode.insertBefore(t,s)}(window, document,'script',
      'https://connect.facebook.net/en_US/fbevents.js');
      fbq('init', '1775596122750375');
    </script>
    <!-- End Meta Pixel (init) -->

    <!-- Meta Pixel helpers: unique event_id + fbclid + SPA route tracking -->
    <script>
      // RFC4122-ish UUID for event_id
      function convUUID(){
        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g,c=>{
          const r=(crypto.getRandomValues(new Uint8Array(1))[0]&15);
          const v=c==='x'?r:(r&0x3)|0x8; return v.toString(16);
        });
      }

      // Capture and persist fbclid from query params
      (function(){
        try {
          const params = new URLSearchParams(location.search);
          const cid = params.get('fbclid');
          if (cid) {
            localStorage.setItem('fb_click_id', cid);
          }
        } catch (e) {
          // no-op
        }
      })();

      function getFBClickId(){
        try { return localStorage.getItem('fb_click_id') || undefined; }
        catch { return undefined; }
      }

      // Wrapper to attach an eventID and fbc; returns the id we used
      window.fbTrack = function(eventName, props){
        props = props || {};
        if (!props.eventID) props.eventID = convUUID();
        const clickId = props.fbc || getFBClickId();
        if (clickId) props.fbc = `fb.1.${Date.now()}.${clickId}`;
        if (window.fbq) {
          if (eventName === 'Custom' && props.custom_event_name) {
            fbq('trackCustom', props.custom_event_name, props);
          } else {
            fbq('track', eventName, props);
          }
        }
        return props.eventID;
      };

      // Update advanced matching user signals after email capture
      window.fbSetUser = function(props){
        props = props || {};
        if (props.email && window.fbq) {
          fbq('init', '1775596122750375', { em: props.email });
        }
      };

      // Fire initial page view
      window.fbTrack('PageView');

      // SPA route tracking + business events
      (function(){
        function onRoute(){
          const path = (location.pathname || '').toLowerCase();

          // Assessment start
          if (path.startsWith('/assessment')) {
            window.fbTrack('ViewContent', { content_name: 'Assessment' });
          }
          // Completion (tune to your actual results/complete paths)
          if (path.includes('result') || path.includes('complete') || path.includes('done')) {
            window.fbTrack('Custom', { custom_event_name: 'AssessmentComplete' });
          }
          // Post-signup destinations
          if (
            path.startsWith('/signup/complete') ||
            path.startsWith('/welcome') ||
            path.includes('/account/create/complete')
          ) {
            window.fbTrack('CompleteRegistration');
          }
        }

        // initial load
        onRoute();

        // watch SPA nav
        ['pushState','replaceState'].forEach(method=>{
          const orig = history[method];
          history[method] = function(){
            const ret = orig.apply(this, arguments);
            setTimeout(()=>{ window.fbTrack('PageView'); onRoute(); }, 0);
            return ret;
          };
        });
        addEventListener('popstate', ()=>{ window.fbTrack('PageView'); onRoute(); });

        // Optional explicit app hooks
        addEventListener('app:assessment:complete', ()=> {
          window.fbTrack('Custom', { custom_event_name: 'AssessmentComplete' });
        });
        addEventListener('app:user:signup', ()=> {
          window.fbTrack('CompleteRegistration');
        });
      })();
    </script>
    <!-- End Meta Pixel helpers -->
    <!-- LinkedIn Insight Tag (init) -->
    <script type="text/javascript">
      _linkedin_partner_id = "7877778";
      window._linkedin_data_partner_ids = window._linkedin_data_partner_ids || [];
      window._linkedin_data_partner_ids.push(_linkedin_partner_id);
    </script>
    <script type="text/javascript">
      (function(l) {
        if (!l) {
          window.lintrk = function(a, b) { window.lintrk.q.push([a, b]); };
          window.lintrk.q = [];
        }
        var s = document.getElementsByTagName("script")[0];
        var b = document.createElement("script");
        b.type = "text/javascript"; b.async = true;
        b.src = "https://snap.licdn.com/li.lms-analytics/insight.min.js";
        s.parentNode.insertBefore(b, s);
      })(window.lintrk);
    </script>
    <!-- End LinkedIn Insight Tag (init) -->

    <!-- LinkedIn Insight Tag helpers: SPA route tracking -->
    <script>
      (function() {
        function onRoute() {
          const path = (location.pathname || '').toLowerCase();
          if (path.startsWith('/assessment')) {
            window.lintrk && window.lintrk('track', { conversion_id: 7877778 });
          }
        }
        onRoute();
        ['pushState','replaceState'].forEach(method => {
          const orig = history[method];
          history[method] = function() {
            const ret = orig.apply(this, arguments);
            setTimeout(onRoute, 0);
            return ret;
          };
        });
        addEventListener('popstate', onRoute);
      })();
    </script>
    <!-- End LinkedIn Insight Tag helpers -->
    <!-- Reddit Pixel (init) -->
    <script>
      !function(w,d){if(!w.rdt){var p=w.rdt=function(){p.sendEvent?p.sendEvent.apply(p,arguments):p.callQueue.push(arguments)};p.callQueue=[];
      var t=d.createElement("script");t.src="https://www.redditstatic.com/ads/pixel.js";t.async=!0;
      var s=d.getElementsByTagName("script")[0];s.parentNode.insertBefore(t,s)}}(window,document);
      // Use configurable pixel ID from app config or fallback
      const redditPixelId = (window.__APP_CONFIG__ && window.__APP_CONFIG__.REDDIT_PIXEL_ID) || 'a2_hisg7r10d2ta';
      rdt('init', redditPixelId);
    </script>
    <!-- End Reddit Pixel (init) -->

    <!-- Reddit Pixel helpers: unique conversion_id + click_id + SPA route tracking -->
    <script>
      // RFC4122-ish UUID for conversion_id
      function convUUID(){
        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g,c=>{
          const r=(crypto.getRandomValues(new Uint8Array(1))[0]&15);
          const v=c==='x'?r:(r&0x3)|0x8; return v.toString(16);
        });
      }

      // Capture and persist Reddit click IDs from query params
      (function(){
        try {
          const params = new URLSearchParams(location.search);
          const cid = params.get('rdt_cid');
          if (cid) {
            localStorage.setItem('rdt_click_id', cid);
          }
        } catch (e) {
          // no-op
        }
      })();

      function getClickId(){
        try { return localStorage.getItem('rdt_click_id') || undefined; }
        catch { return undefined; }
      }

      let redditCustomNameWarned = false;

      // Wrapper to always attach a conversion_id and click_id; returns the id we used
        window.rdtTrack = function(eventName, props){
          props = props || {};
          if (eventName === 'Custom') {
            const customName = props.custom_event_name || props.customEventName || props.name;
            if (!customName) {
              if (!redditCustomNameWarned) {
                redditCustomNameWarned = true;
                console.warn('Reddit Custom event skipped: missing custom event name', props);
              }
              return '';
            }
            props.custom_event_name = customName;
            props.customEventName = customName;
          }
          if (!props.conversion_id) props.conversion_id = convUUID();
          const clickId = props.click_id || getClickId();
          if (clickId) props.click_id = clickId;
          if (props.email && window.redditNormalizeEmail) {
            props.email = window.redditNormalizeEmail(props.email);
          }
          if (window.rdt) rdt('track', eventName, props);
          const customName = eventName === 'Custom' ? props.custom_event_name : undefined;
          const requestBody = {
            event_name: customName || eventName,
            event_type: eventName,
            conversion_id: props.conversion_id,
            click_id: props.click_id,
            email: props.email,
            ...(customName ? { custom_event_name: customName } : {}),
          };
          const requestInit = {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(requestBody),
            keepalive: true,
          };
          try {
            const invoke = window.__supabaseFunctionFetch;
            if (typeof invoke === 'function') {
              invoke('reddit-capi', requestInit).catch(() => {});
            } else {
              fetch('/functions/v1/reddit-capi', requestInit).catch(() => {});
            }
          } catch (e) {
            // no-op
          }
          window.__lastConversionId = props.conversion_id; // for CAPI dedup
          return props.conversion_id;
        };

      // Update advanced matching user signals after email capture
      window.rdtSetUser = function(props){
        props = props || {};
        if (props.email && window.redditNormalizeEmail) {
          props.email = window.redditNormalizeEmail(props.email);
        }
        const pixelId = (window.__APP_CONFIG__ && window.__APP_CONFIG__.REDDIT_PIXEL_ID) || 'a2_hisg7r10d2ta';
        if (window.rdt) rdt('init', pixelId, props);
      };

      // Fire initial page view
      window.rdtTrack('PageVisit');

      // SPA route tracking + business events
      (function(){
        function onRoute(){
          window.rdtTrack('PageVisit');

          const path = (location.pathname || '').toLowerCase();

          // Assessment start
          if (path.startsWith('/assessment')) {
            window.rdtTrack('ViewContent', { content_name: 'Assessment' });
          }
          // Completion (tune to your actual results/complete paths)
          if (path.includes('result') || path.includes('complete') || path.includes('done')) {
            window.rdtTrack('Custom', { custom_event_name: 'AssessmentComplete' });
          }
          // Post-signup destinations
          if (
            path.startsWith('/signup/complete') ||
            path.startsWith('/welcome') ||
            path.includes('/account/create/complete')
          ) {
            window.rdtTrack('SignUp');
          }
        }

        // initial load
        onRoute();

        // watch SPA nav
        ['pushState','replaceState'].forEach(method=>{
          const orig = history[method];
          history[method] = function(){
            const ret = orig.apply(this, arguments);
            setTimeout(onRoute, 0);
            return ret;
          };
        });
        addEventListener('popstate', onRoute);

        // Optional explicit app hooks
        addEventListener('app:assessment:complete', ()=> {
          window.rdtTrack('Custom', { custom_event_name: 'AssessmentComplete' });
        });
        addEventListener('app:user:signup', ()=> {
          window.rdtTrack('SignUp');
        });
      })();
    </script>
    <!-- End Reddit helpers -->

    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>About PRISM — Model, Methods, and Confidence</title>
    <meta name="description" content="Learn how PRISM (Personality • Regulation • Information System Mapping) measures information elements, dimensionality (1D–4D), block dynamics, and a ± overlay, using multi-method items and confidence-based scoring." />
    <meta name="author" content="PRISM Personality System" />
    <link rel="icon" href="/lovable-uploads/5e9af605-c408-4bf3-ac7d-7d379b09af9b.png" type="image/png">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

    <meta property="og:title" content="About PRISM — Model, Methods, and Confidence" />
    <meta property="og:description" content="Learn how PRISM measures information processing, dimensionality, and state overlays using rigorous multi-method assessment design." />
    <meta property="og:type" content="website" />
    <meta property="og:image" content="/lovable-uploads/5e9af605-c408-4bf3-ac7d-7d379b09af9b.png" />

    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:site" content="@prism_personality" />
    <meta name="twitter:image" content="/lovable-uploads/5e9af605-c408-4bf3-ac7d-7d379b09af9b.png" />

    <!-- Twitter Pixel (base loader) -->
    <script>
      !(function(w, d, s, u, a, b) {
        const debug = w.__TW_DEBUG__ === true;
        if (w.twq) {
          if (debug) {
            console.info('[Twitter Pixel] twq stub already present');
          }
          return;
        }
        u = w.twq = function() {
          if (u.exe) {
            u.exe.apply(u, arguments);
          } else {
            u.queue.push(arguments);
          }
        };
        u.version = '1.1';
        u.queue = [];
        a = d.createElement(s);
        a.async = true;
        a.src = 'https://static.ads-twitter.com/uwt.js';
        if (debug) {
          console.info('[Twitter Pixel] Loader stub defined; requesting uwt.js', { src: a.src });
          a.addEventListener('load', () => {
            console.info('[Twitter Pixel] uwt.js loaded');
          });
          a.addEventListener('error', (event) => {
            console.error('[Twitter Pixel] Failed to load uwt.js', event);
            w.__TW_LAST_ERROR__ = 'Failed to load uwt.js';
          });
        }
        b = d.getElementsByTagName(s)[0];
        b.parentNode.insertBefore(a, b);
      })(window, document, 'script');
    </script>
    <!-- End Twitter Pixel (base loader) -->

    <!-- Twitter Pixel helpers: consent, dedupe, and results-page safety -->
    <script>
      (function configureTwitterPixel() {
        const PIXEL_ID = 'nwcm8';
        const ALLOW_RESULTS_FLAG = '__allowResults';
        const RESULTS_PATH_PATTERN = /\/results(\/|$)/i;
        const CONSENT_CHECK_INTERVAL = 500;
        const MAX_CONSENT_CHECKS = 40;
        const debug = window.__TW_DEBUG__ === true;
        const forceOverride = window.__TW_FORCE__ === true;
        let configured = false;
        let lastError = window.__TW_LAST_ERROR__ || null;
        let lastConfigFailure = null;
        let cmpAnalyticsConsent = null;
        let tcfAnalyticsConsent = null;
        let cspProbeResult = 'pending';
        let cspProbeAttempted = false;
        let cmpListenerRegistered = false;
        let tcfListenerRegistered = false;
        let cmpLastPoll = 0;
        let tcfLastPoll = 0;
        const CMP_POLL_INTERVAL = 5000;
        const TCF_POLL_INTERVAL = 5000;

        if (debug) {
          console.info(
            '[Twitter Pixel] Required CSP domains (img-src & connect-src): static.ads-twitter.com, ads-twitter.com, ads-api.twitter.com, analytics.twitter.com, t.co',
          );
        }

        function debugLog(level, message, payload) {
          if (!debug) return;
          const logger = typeof console[level] === 'function' ? console[level] : console.log;
          if (payload !== undefined) {
            logger.call(console, `[Twitter Pixel] ${message}`, payload);
          } else {
            logger.call(console, `[Twitter Pixel] ${message}`);
          }
        }

        function setLastError(message) {
          lastError = message;
          if (message) {
            window.__TW_LAST_ERROR__ = message;
          } else {
            delete window.__TW_LAST_ERROR__;
          }
        }

        function interpretConsentValue(value) {
          if (value === null || value === undefined) return null;
          if (typeof value === 'boolean') return value;
          if (typeof value === 'number') return value === 1;
          if (typeof value === 'string') {
            const normalized = value.toLowerCase();
            if (['granted', 'true', '1', 'allow', 'allowed', 'accepted', 'consent', 'yes', 'on'].includes(normalized)) {
              return true;
            }
            if (['denied', 'declined', 'false', '0', 'refused', 'revoked', 'no', 'off'].includes(normalized)) {
              return false;
            }
          }
          return null;
        }

        function evaluateConsentFromObject(source) {
          if (!source || typeof source !== 'object') return null;
          const keys = [
            'analytics',
            'Analytics',
            'statistics',
            'Statistics',
            'performance',
            'Performance',
            'measurement',
            'Measurement',
            'consentAnalytics',
            'analyticsConsent',
            'measurementConsent',
          ];
          for (const key of keys) {
            if (key in source) {
              const interpreted = interpretConsentValue(source[key]);
              if (interpreted !== null) return interpreted;
            }
          }
          const categoryArrays = [
            source.categories,
            source.allowedCategories,
            source.acceptedCategories,
            source.grantedCategories,
            source.enabled,
            source.enabledCategories,
          ];
          const acceptedValues = ['analytics', 'measurement', 'statistics', 'performance'];
          for (const arrayCandidate of categoryArrays) {
            if (Array.isArray(arrayCandidate)) {
              if (arrayCandidate.some((value) => typeof value === 'string' && acceptedValues.includes(value.toLowerCase()))) {
                return true;
              }
            }
          }
          return null;
        }

        function evaluateCmpResult(result) {
          if (!result || typeof result !== 'object') return null;
          const direct = evaluateConsentFromObject(result);
          if (direct !== null) return direct;
          const purposeConsents = result.purposeConsents || result.purposes || result.purpose || result.categories;
          if (purposeConsents && typeof purposeConsents === 'object') {
            const purposeKeys = ['analytics', 'measurement', 'statistics', 'performance', '7', '8', '9', '10'];
            for (const key of purposeKeys) {
              if (key in purposeConsents) {
                const interpreted = interpretConsentValue(purposeConsents[key]);
                if (interpreted !== null) return interpreted;
              }
            }
          }
          return null;
        }

        function evaluateTcData(tcData) {
          if (!tcData || typeof tcData !== 'object') return null;
          const direct = evaluateConsentFromObject(tcData);
          if (direct !== null) return direct;
          const consents = tcData.purpose && tcData.purpose.consents;
          if (consents && typeof consents === 'object') {
            const purposeKeys = ['7', '8', '9', '10'];
            for (const key of purposeKeys) {
              if (key in consents) {
                const interpreted = interpretConsentValue(consents[key]);
                if (interpreted !== null) return interpreted;
              }
            }
          }
          if (tcData.specialFeatureOptins && typeof tcData.specialFeatureOptins === 'object') {
            const measurementOptIn = interpretConsentValue(tcData.specialFeatureOptins['1']);
            if (measurementOptIn !== null) return measurementOptIn;
          }
          return null;
        }

        function refreshCmpConsent() {
          const cmp = window.__cmp;
          if (typeof cmp !== 'function') return;
          const now = Date.now();
          if (cmpAnalyticsConsent === null || now - cmpLastPoll >= CMP_POLL_INTERVAL) {
            cmpLastPoll = now;
            try {
              cmp('getConsentState', null, (result, success) => {
                if (!success) return;
                const interpreted = evaluateCmpResult(result);
                if (interpreted !== null) {
                  cmpAnalyticsConsent = interpreted;
                  debugLog('info', 'CMP analytics consent updated', { source: 'getConsentState', value: interpreted });
                  ensureConfigured('cmp-getConsentState');
                }
              });
            } catch (error) {
              debugLog('warn', 'CMP getConsentState failed', error);
            }
          }
          if (!cmpListenerRegistered) {
            try {
              cmp('addEventListener', null, (event) => {
                if (!event) return;
                const interpreted = evaluateCmpResult(event);
                if (interpreted !== null) {
                  cmpAnalyticsConsent = interpreted;
                  debugLog('info', 'CMP analytics consent event', { value: interpreted });
                  ensureConfigured('cmp-event');
                }
              });
              cmpListenerRegistered = true;
            } catch (error) {
              cmpListenerRegistered = false;
              debugLog('debug', 'CMP addEventListener unavailable', error);
            }
          }
        }

        function refreshTcfConsent() {
          const tcfapi = window.__tcfapi;
          if (typeof tcfapi !== 'function') return;
          const now = Date.now();
          if (tcfAnalyticsConsent === null || now - tcfLastPoll >= TCF_POLL_INTERVAL) {
            tcfLastPoll = now;
            try {
              tcfapi('getTCData', 2, (tcData, success) => {
                if (!success) return;
                const interpreted = evaluateTcData(tcData);
                if (interpreted !== null) {
                  tcfAnalyticsConsent = interpreted;
                  debugLog('info', 'TCF analytics consent updated', { source: 'getTCData', value: interpreted });
                  ensureConfigured('tcf-getTCData');
                }
              });
            } catch (error) {
              debugLog('warn', 'TCF getTCData failed', error);
            }
          }
          if (!tcfListenerRegistered) {
            try {
              tcfapi('addEventListener', 2, (tcData, success) => {
                if (!success) return;
                const interpreted = evaluateTcData(tcData);
                if (interpreted !== null) {
                  tcfAnalyticsConsent = interpreted;
                  debugLog('info', 'TCF analytics consent event', { value: interpreted, eventStatus: tcData && tcData.eventStatus });
                  ensureConfigured('tcf-event');
                }
              });
              tcfListenerRegistered = true;
            } catch (error) {
              tcfListenerRegistered = false;
              debugLog('debug', 'TCF addEventListener unavailable', error);
            }
          }
        }

        function sanitisePayloadForLog(payload) {
          if (!payload || typeof payload !== 'object') return payload;
          const clone = Object.assign({}, payload);
          if ('email_address' in clone) clone.email_address = '[redacted]';
          if ('email' in clone) clone.email = '[redacted]';
          if ('phone_number' in clone) clone.phone_number = '[redacted]';
          if ('phone' in clone) clone.phone = '[redacted]';
          return clone;
        }

        function refreshConsentSignals() {
          refreshCmpConsent();
          refreshTcfConsent();
        }

        function hasAnalyticsConsent() {
          if (forceOverride) return true;
          const direct = evaluateConsentFromObject(window.__consent);
          if (direct !== null) return direct;
          if (cmpAnalyticsConsent !== null) return cmpAnalyticsConsent;
          if (tcfAnalyticsConsent !== null) return tcfAnalyticsConsent;
          return false;
        }

        function recordFailure(message, detail) {
          setLastError(message);
          if (!debug) return;
          if (lastConfigFailure !== message) {
            console.warn('[Twitter Pixel]', message, detail || undefined);
          }
          lastConfigFailure = message;
        }

        function clearFailures() {
          setLastError(null);
          lastConfigFailure = null;
        }

        function logDebugSummary(stage) {
          if (!debug) return;
          const status = {
            hasTwq: typeof window.twq === 'function',
            configured,
            consent: hasAnalyticsConsent(),
            pathname: window.location.pathname,
            csp: cspProbeResult,
          };
          console.groupCollapsed('[Twitter Pixel] Debug summary');
          console.log(`Stage: ${stage}`);
          console.table([status]);
          console.log(`${status.hasTwq ? '✅' : '❌'} hasTwq`);
          console.log(`${status.configured ? '✅' : '❌'} configured`);
          console.log(`${status.consent ? '✅' : '❌'} consent`);
          const cspIndicator = status.csp === 'ok' ? '✅' : status.csp === 'blocked' ? '❌' : '⚠️';
          console.log(`${cspIndicator} CSP (${status.csp})`);
          console.log(`Path: ${status.pathname}`);
          if (lastError) {
            console.log('Last error:', lastError);
          }
          console.groupEnd();
        }

        function ensureConfigured(context) {
          if (configured) return true;
          if (!hasAnalyticsConsent()) {
            recordFailure('Waiting for analytics consent', { context });
            return false;
          }
          if (typeof window.twq !== 'function') {
            recordFailure('Twitter Pixel loader not ready', { context });
            return false;
          }
          try {
            debugLog('info', `Configuring Twitter Pixel (${PIXEL_ID})`, { context, forceOverride });
            window.twq('config', PIXEL_ID, { use_1p: true });
            configured = true;
            clearFailures();
            debugLog('info', 'Twitter Pixel configured', { context });
            logDebugSummary('configured');
            return true;
          } catch (error) {
            recordFailure('Twitter Pixel configuration error', error);
            return false;
          }
        }

        function scheduleConsentChecks() {
          let attempts = 0;
          const timer = window.setInterval(() => {
            attempts += 1;
            refreshConsentSignals();
            if (ensureConfigured('consent-interval') || attempts >= MAX_CONSENT_CHECKS) {
              window.clearInterval(timer);
            }
          }, CONSENT_CHECK_INTERVAL);
        }

        function captureTwclid() {
          try {
            const params = new URLSearchParams(window.location.search);
            const clickId = params.get('twclid');
            if (clickId) {
              localStorage.setItem('twclid', clickId);
              debugLog('info', 'Captured twclid', { clickId });
            }
          } catch (error) {
            debugLog('warn', 'Twitter Pixel click id capture failed (non-blocking)', error);
          }
        }

        function getStoredTwclid() {
          try {
            return localStorage.getItem('twclid') || undefined;
          } catch (error) {
            debugLog('debug', 'Unable to access stored twclid', error);
            return undefined;
          }
        }

        function generateConversionId() {
          try {
            return crypto.randomUUID();
          } catch (error) {
            debugLog('debug', 'crypto.randomUUID unavailable, using fallback', error);
            return `${Date.now().toString(36)}-${Math.random().toString(36).slice(2)}`;
          }
        }

        function attachConsentListeners() {
          const events = ['consent:updated', 'app:consent:updated', 'consentchange'];
          events.forEach((eventName) => {
            if (typeof window.addEventListener === 'function') {
              window.addEventListener(
                eventName,
                () => {
                  refreshConsentSignals();
                  ensureConfigured(`event:${eventName}`);
                },
                { passive: true },
              );
            }
            if (typeof document.addEventListener === 'function') {
              document.addEventListener(
                eventName,
                () => {
                  refreshConsentSignals();
                  ensureConfigured(`event:${eventName}`);
                },
                { passive: true },
              );
            }
          });
        }

        function runCspProbe() {
          if (!debug || typeof fetch !== 'function' || cspProbeAttempted) return;
          cspProbeAttempted = true;
          fetch('https://static.ads-twitter.com/uwt.js', { mode: 'no-cors', cache: 'no-store' })
            .then(() => {
              cspProbeResult = 'ok';
              debugLog('info', 'CSP probe succeeded');
              logDebugSummary('csp-ok');
            })
            .catch((error) => {
              cspProbeResult = 'blocked';
              recordFailure('Twitter Pixel loader blocked (CSP or network)', error);
              console.error(
                '[Twitter Pixel] uwt.js fetch failed. Ensure CSP allows static.ads-twitter.com, ads-twitter.com, ads-api.twitter.com, analytics.twitter.com, and t.co in both img-src and connect-src.',
              );
              logDebugSummary('csp-error');
            });
        }

        window.__twStatus = function __twStatus() {
          return {
            hasTwq: typeof window.twq === 'function',
            configured,
            consent: hasAnalyticsConsent(),
            path: window.location.pathname,
            lastError: lastError || null,
            csp: cspProbeResult,
          };
        };

        window.twqTrack = function twqTrack(eventName, properties) {
          refreshConsentSignals();
          const hasConsent = hasAnalyticsConsent();
          if (!ensureConfigured(`track:${eventName}`)) {
            if (debug) {
              const reason = hasConsent ? 'pixel not ready' : 'missing consent';
              debugLog('info', `Dropping ${eventName} event (${reason})`, {
                event: eventName,
                path: window.location.pathname,
              });
            }
            return undefined;
          }

          const payload = Object.assign({}, properties);
          const allowOnResults = Boolean(payload && payload[ALLOW_RESULTS_FLAG]);
          if (payload && ALLOW_RESULTS_FLAG in payload) {
            delete payload[ALLOW_RESULTS_FLAG];
          }

          const onResultsRoute = RESULTS_PATH_PATTERN.test(window.location.pathname || '');
          if (onResultsRoute && eventName !== 'PageView' && !allowOnResults) {
            recordFailure('Event suppressed on results route');
            if (debug) {
              debugLog('info', `Dropping ${eventName} on results route`, {
                path: window.location.pathname,
              });
            }
            return undefined;
          }

          if (!payload.conversion_id) {
            payload.conversion_id = generateConversionId();
          }

          if (!payload.twclid) {
            const storedClickId = getStoredTwclid();
            if (storedClickId) payload.twclid = storedClickId;
          }

          try {
            window.twq('track', eventName, payload);
            clearFailures();
            if (debug) {
              debugLog('info', `Sent ${eventName}`, {
                payload: sanitisePayloadForLog(payload),
              });
            }
          } catch (error) {
            recordFailure('Twitter Pixel track error', error);
          }

          return payload.conversion_id;
        };

        if (debug) {
          window.twqTest = function twqTest() {
            const conversionId = window.twqTrack
              ? window.twqTrack('Lead', { test: true, [ALLOW_RESULTS_FLAG]: true })
              : undefined;
            debugLog('info', 'twqTest invoked', { conversionId });
            return conversionId;
          };
        } else if ('twqTest' in window) {
          try {
            delete window.twqTest;
          } catch (error) {
            // no-op if delete fails
          }
        }

        captureTwclid();
        attachConsentListeners();
        refreshConsentSignals();
        if (!ensureConfigured('initial')) {
          scheduleConsentChecks();
        }
        logDebugSummary('init');
        runCspProbe();
      })();
    </script>
    <!-- End Twitter Pixel helpers -->
  </head>

  <body>
    <!-- Google Tag Manager (noscript) -->
    <noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-M66MXTL9"
    height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
    <!-- End Google Tag Manager (noscript) -->

    <!-- LinkedIn Insight Tag noscript fallback -->
    <noscript>
      <img height="1" width="1" style="display:none;" alt=""
        src="https://px.ads.linkedin.com/collect/?pid=7877778&fmt=gif" />
    </noscript>

    <!-- Reddit Pixel noscript fallback -->
    <noscript>
      <img height="1" width="1" style="display:none" src="https://www.reddit.com/tr?id=a2_hisg7r10d2ta&ev=PageVisit&noscript=1">
    </noscript>

    <!-- Twitter Pixel noscript fallback -->
    <noscript>
      <img
        height="1"
        width="1"
        style="display:none"
        alt=""
        src="https://analytics.twitter.com/i/adsct?txn_id=nwcm8&p_id=Twitter&tw_sale_amount=0&tw_order_quantity=0"
      />
      <img
        height="1"
        width="1"
        style="display:none"
        alt=""
        src="https://t.co/i/adsct?txn_id=nwcm8&p_id=Twitter&tw_sale_amount=0&tw_order_quantity=0"
      />
    </noscript>

    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>
